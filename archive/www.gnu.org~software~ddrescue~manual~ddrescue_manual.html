<html lang=en style><!--
 Page saved with SingleFile 
 url: https://www.gnu.org/software/ddrescue/manual/ddrescue_manual.html 
 saved date: Thu Aug 12 2021 09:25:26 GMT-0400 (Eastern Daylight Time)
--><meta charset=utf-8>
<title>GNU ddrescue Manual</title>
<meta name=description content="GNU ddrescue Manual">
<meta name=generator content="makeinfo 4.13+">
<link title=Top rel=top href=#Top>
<link href=http://www.gnu.org/software/texinfo/ rel=generator-home title="Texinfo Homepage">
<meta http-equiv=Content-Style-Type content=text/css>
<style><!----></style>
<link type=image/x-icon rel="shortcut icon" href=data:image/vnd.microsoft.icon;base64,AAABAAEAEhIAAAEACADYBQAAFgAAACgAAAASAAAAJAAAAAEACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgYGAAkJCQALCwsAExMTACEhIQAkJCQAJycnADMzMwA5OTkAOjo6AD09PQA/Pz8AQEBAAEZGRgBHR0cASkpKAE9PTwBSUlIAW1tbAGFhYQBmZmYAbW1tAHFxcQBzc3MAd3d3AHl5eQB+fn4Af39/AIGBgQCEhIQAh4eHAIyMjACNjY0Aj4+PAJCQkACRkZEAlZWVAJeXlwCampoAm5ubAJycnAChoaEAoqKiAKWlpQCnp6cAqKioAK2trQCvr68AsLCwALGxsQCysrIAs7OzALa2tgC7u7sAvb29AL+/vwDBwcEAwsLCAMPDwwDExMQAxcXFAMbGxgDHx8cAycnJAMrKygDLy8sAzMzMAM3NzQDOzs4A0NDQANHR0QDT09MA1NTUANXV1QDW1tYA19fXANjY2ADZ2dkA2traANzc3ADd3d0A39/fAOHh4QDi4uIA4+PjAOTk5ADm5uYA6OjoAOnp6QDr6+sA7OzsAO3t7QDu7u4A7+/vAPHx8QDz8/MA9PT0APX19QD29vYA9/f3APj4+AD5+fkA+/v7APz8/AD+/v4A////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAampqampqampqampqampqampqAABqampqampqalQQAQdmampqamoAAGpqampqamFqFiUaMmpqampqagAAampqampDaDQSaltLampqampqAABqampqUVleImpqQCQxampqamoAAGpqamo5aihgakBEPCpQampqagAAampqajteUWpmR2ppUUFqampqAABqamceHj5gaFhWJ1hqP2pqamoAAGpqajRqRkhdajRIVDY0SVpqagAAampYOlVqLGplX2piKmNITmpqAABqV0MPI2pqWwxKZRE9agY5TGoAAGpPAxUIZFwXajhYH1UiDQQwagAAakAJV0oOGC8uTTk7HBRXLSFqAABqNRNcakMIAAAoNwILVGpKGmoAAGpQBVtqalQjIz0mIFJqaiUjagAAakwZGjlQRVdqampYSkczCkNqAABqak8rHRtCVmpqalxBKSNTZ2oAAGpqampqampqampqampqampqagAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA><link rel=canonical href=https://www.gnu.org/software/ddrescue/manual/ddrescue_manual.html><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:;"></head>
<body class=vsc-initialized>
<div class=node>
<a name=Top></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Introduction>Introduction</a>,
Up:&nbsp;<a rel=up accesskey=u href=#dir>(dir)</a>
</div>
<h2 class=unnumbered>GNU ddrescue Manual</h2>
<p>This manual is for GNU ddrescue (version 1.25, 21 February 2020).
<ul class=menu>
<li><a accesskey=1 href=#Introduction>Introduction</a>: Purpose and features of GNU ddrescue
<li><a accesskey=2 href=#Basic-concepts>Basic concepts</a>: Blocks, clusters, devices, files, sectors, etc
<li><a accesskey=3 href=#Important-advice>Important advice</a>: Read this or risk losing your data
<li><a accesskey=4 href=#Algorithm>Algorithm</a>: How ddrescue recovers the data
<li><a accesskey=5 href=#Output>Output</a>: Meaning of ddrescue's screen output
<li><a accesskey=6 href=#Invoking-ddrescue>Invoking ddrescue</a>: Command line interface
<li><a accesskey=7 href=#Mapfile-structure>Mapfile structure</a>: Detailed format of the mapfile
<li><a accesskey=8 href=#Emergency-save>Emergency save</a>: Saving the mapfile in case of trouble
<li><a accesskey=9 href=#Optical-media>Optical media</a>: Copying CD-ROMs and DVDs
<li><a href=#Examples>Examples</a>: A small tutorial with examples
<li><a href=#Direct-disc-access>Direct disc access</a>: Bypassing the kernel cache
<li><a href=#Command-mode>Command mode</a>: Copying parts of the input file on demand
<li><a href=#Fill-mode>Fill mode</a>: Selectively overwriting the output file
<li><a href=#Generate-mode>Generate mode</a>: Generating an approximate mapfile
<li><a href=#Ddrescuelog>Ddrescuelog</a>: Tool for ddrescue mapfiles
<li><a href=#Invoking-ddrescuelog>Invoking ddrescuelog</a>: Command line interface
<li><a href=#Problems>Problems</a>: Reporting bugs
<li><a href=#Concept-index>Concept index</a>: Index of concepts
</ul>
 <pre class=sp></pre>
Copyright Â© 2004-2020 Antonio Diaz Diaz.
 <p>This manual is free documentation: you have unlimited permission to copy,
distribute, and modify it.
<div class=node>
<a name=Introduction></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Basic-concepts>Basic concepts</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Top>Top</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>1 Introduction</h2>
<p><a name=index-introduction-1></a>
<a href=http://www.gnu.org/software/ddrescue/ddrescue.html>GNU ddrescue</a> is a
data recovery tool. It copies data from one file or block device (hard disc,
cdrom, etc) to another, trying to rescue the good parts first in case of
read errors.
 <p>The basic operation of ddrescue is fully automatic. That is, you don't have
to wait for an error, stop the program, restart it from a new position, etc.
 <p>If you use the mapfile feature of ddrescue, the data are rescued very
efficiently, (only the blocks needed are read). Also you may interrupt the
rescue at any time and resume it later at the same point. The mapfile is an
essential part of ddrescue's effectiveness. Use it unless you know what you
are doing.
 <p>Ddrescue does not write zeros to the output when it finds bad sectors in the
input, and does not truncate the output file if not asked to. So, every time
you run it on the same output file, it tries to fill in the gaps without
wiping out the data already rescued.
 <p>Automatic merging of backups: If you have two or more damaged copies of a
file, cdrom, etc, and run ddrescue on all of them, one at a time, with the
same output file, you will probably obtain a complete and error-free file. 
This is so because the probability of having the same area damaged in all
copies is low (if the errors are randomly located). Using the mapfile, only
the blocks needed are read from the second and successive copies.
 <p>Ddrescue recommends <a href=http://www.nongnu.org/lzip/lzip.html>lzip</a> for
compression of backups because the lzip format is designed for long-term
archiving and provides data recovery capabilities which nicely complement
those of ddrescue. (Ddrescue fills unreadable sectors with data from other
copies, while lziprecover corrects corrupt sectors with data from other
copies). If the cause of file corruption is damaged media, the combination
ddrescue&nbsp;+&nbsp;lziprecover is the best option for recovering data from
multiple damaged copies. See <a href=#lziprecover_002dexample>lziprecover-example</a>.
 <p>Because ddrescue needs to read and write at random places, it only works on
seekable (random access) input and output files.
 <p>If your system supports it, ddrescue can use direct disc access to read the
input file, bypassing the kernel cache.
 <p>Ddrescue also features a 'fill mode' able to selectively overwrite parts of
the output file, which has a number of interesting uses like wiping data,
marking bad areas, or even, in some cases, "repair" damaged sectors.
 <p>One of the great strengths of ddrescue is that it is interface-agnostic, and
so can be used for any kind of device supported by your kernel (ATA, SATA,
SCSI, old MFM drives, floppy discs, or even flash media cards like SD).
<div class=node>
<a name=Basic-concepts></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Important-advice>Important advice</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Introduction>Introduction</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>2 Basic concepts</h2>
<p><a name=index-basic-concepts-2></a>
 <dl>
<dt>Block<dd>Any amount of data. A block is described by its starting position and
its size. The starting position (or beginning position) is the lowest
position in the block. The end of the block is its starting position
plus its size.
 <br><dt>Cluster<dd>Group of consecutive sectors read or written in one go.
 <br><dt>Device<dd>Piece of hardware containing data. Hard disc drives, cdrom drives, USB
pendrives, are devices. /dev/hda, /dev/sdb, are device names.
 <br><dt>File<dd>Files are named units of data which are stored by the operating system
for you to retrieve later by name. Devices and partitions are accessed
by means of their associated file names.
 <br><dt>Partition<dd>Every part in which a device is divided. A partition normally contains a
file system. /dev/hda1, /dev/sdb3, are partition names.
 <br><dt>Recoverable formats<dd>As ddrescue uses standard library functions to read data from the device
being rescued, only mountable device formats can be rescued with
ddrescue. CD-ROMs and DVDs can be rescued, "compact disc digital audio"
CDs can't, "video CDs"[1] maybe.<br> [1]
http://en.wikipedia.org/wiki/Video_CD
 <br><dt>Rescue domain<dd>Block or set of blocks to be acted upon (rescued, listed, etc). You may
define it with the options '<samp><span class=samp>--input-position</span></samp>', '<samp><span class=samp>--size</span></samp>', and
'<samp><span class=samp>--domain-mapfile</span></samp>'. The rescue domain defaults to the whole input
file or mapfile. If ddrescue can't determine the size of the input file,
the rescue domain defaults to the maximum size of a block (at least
2^63&nbsp;-&nbsp;1 bytes, or 8 EiB minus 1 byte).
 <p>Ddrescue will never try to read any data outside of the rescue domain
except when unaligned direct disc access is requested (see <a href=#Direct-disc-access>Direct disc access</a>). If it does, please, report it as a bug.
 <p>The amount of data rescued, number of bad areas, etc, shown by ddrescue
may vary or even become zero if you limit the rescue domain. Don't
worry, they have not disappeared; they are simply out of the specified
rescue domain.
 <br></p><dt>Sector<dd>Hardware block. Smallest accessible amount of data on a device.
 </dl>
<div class=node>
<a name=Important-advice></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Algorithm>Algorithm</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Basic-concepts>Basic concepts</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>3 Using ddrescue safely</h2>
<p><a name=index-using-ddrescue-safely-3></a>
Ddrescue is like any other power tool. You need to understand what it
does, and you need to understand some things about the machines it does
those things to, in order to use it safely.
 <p>Never try to rescue a r/w mounted partition. The resulting copy may be
useless. It is best that the device or partition to be rescued is not
mounted at all, not even read-only.
 <p>Never try to repair a file system on a drive with I/O errors; you will
probably lose even more data.
 <p>If you use a device or a partition as destination, any data stored there
will be overwritten.
 <p>Some systems may change device names on reboot (e.g. udev enabled systems). 
If you reboot, check the device names before restarting ddrescue.
 <p>If you interrupt the rescue and then reboot, any partially copied
partitions should be hidden before allowing them to be touched by any
operating system that tries to mount and "fix" the partitions it sees.
<div class=node>
<a name=Algorithm></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Output>Output</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Important-advice>Important advice</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>4 Algorithm</h2>
<p><a name=index-algorithm-4></a>
GNU ddrescue is not a derivative of dd, nor is related to dd in any way
except in that both can be used for copying data from one device to
another. The key difference is that ddrescue uses a sophisticated
algorithm to copy data from failing drives causing them as little
additional damage as possible.
 <p>Versions of ddrescue prior to 1.19 used a divide-and-conquer strategy to
rescue the difficult parts of the drive. But that caused a lot of head
movement, which is bad for the drive. Therefore, newer versions try to
minimize head movement to minimize drive damage.
 <p>Ddrescue manages efficiently the status of the rescue in progress and
tries to rescue the good parts first, scheduling reads inside bad (or
slow) areas for later. This maximizes the amount of data that can be
finally recovered from a failing drive.
 <p>The standard dd utility can be used to save data from a failing drive,
but it reads the data sequentially, which may wear out the drive without
rescuing anything if the errors are at the beginning of the drive.
 <p>Other programs read the data sequentially but switch to small size reads
when they find errors. This is a bad idea because it means spending more
time at error areas, damaging the surface, the heads, and the drive
mechanics, instead of getting out of them as fast as possible. This
behavior reduces the chances of rescuing the remaining good data.
 <p>The algorithm of ddrescue is as follows (the user may interrupt the
process at any point, but be aware that a bad drive can block ddrescue
for a long time until the kernel gives up):
 <p>1) Optionally read a mapfile describing the status of a multi-part or
previously interrupted rescue. If no mapfile is specified, or is empty, or
does not exist, mark all the rescue domain as non-tried.
 <p>2) (First phase; Copying) Copying is done in up to five passes. The
first pass reads the non-tried parts of the input file, marking the
failed blocks as non-trimmed and skipping beyond them. The second pass
delimits the blocks skipped by the first pass. The first two passes also
skip beyond slow areas. The skipped areas are tried later in one or
three additional passes (before trimming). The copying direction is
reversed after each pass until all the rescue domain is tried.
 <p>The third and fourth passes read the blocks skipped due to slow areas
(if any) by the first two passes, in the same direction that each block
was skipped. For each block, passes 2 to 4 skip the rest of the block
after finding the first error in the block. The last pass is a sweeping
pass, with skipping disabled. The purpose of the multiple passes is to
delimit large bad areas fast, recover the most promising areas first,
keep the mapfile small, and produce good starting points for trimming.
 <p>Only non-tried areas are read in large blocks. Trimming, scraping, and
retrying are done sector by sector. Each sector is tried at most two
times; the first in this phase as part of a large block read, the second
in one of the phases below as a single sector read.
 <p>3) (Second phase; Trimming) Trimming is done in one pass. For each
non-trimmed block, read forwards one sector at a time from the leading
edge of the block until a bad sector is found. Then read backwards one
sector at a time from the trailing edge of the block until a bad sector
is found. Then mark the bad sectors found (if any) as bad-sector, and
mark the rest of the block as non-scraped without trying to read it. If
any edge is already adjacent to a bad sector, it is considered as
already trimmed and is not trimmed again.
 <p>4) (Third phase; Scraping) Scrape together the data not recovered by the
copying or trimming phases. Scraping is done in one pass. Each
non-scraped block is read forwards, one sector at a time. Any bad
sectors found are marked as bad-sector.
 <p>5) (Fourth phase; Retrying) Optionally try to read again the bad sectors
until the specified number of retry passes is reached. The direction is
reversed after each pass. Every bad sector is tried only once in each
pass. Ddrescue can't know if a bad sector is unrecoverable or if it will
be eventually read after some retries.
 <p>6) Optionally write a mapfile for later use.
 <pre class=sp></pre>
When ddrescue finishes the steps above, any areas marked as bad-sector will
remain untouched in the output file. If the output file is a regular file
created by ddrescue, the areas marked as bad-sector will contain zeros. If
it is a device or a previously existing file, the areas marked as bad-sector
will still contain the data previously present there.
 <p>The mapfile is periodically saved to disc, as well as when ddrescue finishes
or is interrupted. A backup copy of the mapfile with the extension
'<samp><span class=samp>.bak</span></samp>' is also periodically created (if possible). So in case of a
crash you can resume the rescue with little recopying. The default interval
between saves varies from 30 seconds to 5 minutes depending on mapfile size
(larger mapfiles are saved at longer intervals), but may be overriden. 
See <a href=#g_t_002d_002dmapfile_002dinterval>--mapfile-interval</a>.
 <p>The same mapfile can be used for multiple commands that copy different areas
of the input file, and for multiple recovery attempts over different
subsets. See this example:
<p class=noindent>Rescue the most important part of the disc first.
<pre class=example>     ddrescue -i0 -s50MiB /dev/sdc hdimage mapfile
     ddrescue -i0 -s1MiB -d -r3 /dev/sdc hdimage mapfile
</pre>
 <p class=noindent>Then rescue some key disc areas.
<pre class=example>     ddrescue -i30GiB -s10GiB /dev/sdc hdimage mapfile
     ddrescue -i230GiB -s5GiB /dev/sdc hdimage mapfile
</pre>
 <p class=noindent>Now rescue the rest (does not recopy what is already done).
<pre class=example>     ddrescue /dev/sdc hdimage mapfile
     ddrescue -d -r3 /dev/sdc hdimage mapfile
</pre>
 <div class=node>
<a name=Output></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Invoking-ddrescue>Invoking ddrescue</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Algorithm>Algorithm</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>5 Meaning of ddrescue's screen output</h2>
<p><a name=index-output-5></a>
The output of ddrescue looks like this:
<pre class=example>     GNU ddrescue 1.25
     Press Ctrl-C to interrupt
     Initial status (read from mapfile)
     rescued: 1665 MB, tried: 0 B, bad-sector: 0 B, bad areas: 0
     
     Current status
          ipos:    2874 MB, non-trimmed:        0 B,  current rate:  21479 kB/s
          opos:    2874 MB, non-scraped:        0 B,  average rate:  21023 kB/s
     non-tried:   13603 MB,  bad-sector:        0 B,    error rate:       0 B/s
       rescued:    2401 MB,   bad areas:        0,        run time:         35s
     pct rescued:   15.00%, read errors:        0,  remaining time:         10m
      slow reads:        5,        time since last successful read:          0s
     Copying non-tried blocks... Pass 1 (forwards)
</pre>
 <p>The meaning of each field is as follows:
 <dl>
<dt><code>ipos</code><dd>Input position. The position in the input file where data are being
currently read from.
 <br><dt><code>opos</code><dd>Output position. The position in the output file where data are being
currently written to.
 <br><dt><code>non-tried</code><dd>Size of the part of the rescue domain pending to be tried. This is the
sum of the sizes of all the non-tried blocks.
 <br><dt><code>rescued</code><dd>Size of the part of the rescue domain already successfully recovered. 
This is the sum of the sizes of all the finished blocks.
 <br><dt><code>pct rescued</code><dd>Percentage of the rescue domain that has been successfully recovered.
 <br><dt><code>slow reads</code><dd>Number of times that the read rate fell below '<samp><span class=samp>--min-read-rate</span></samp>'
during the first two passes of the copying phase. See <a href=#g_t_002d_002dmin_002dread_002drate>--min-read-rate</a>.
 <br><dt><code>tried</code><dd>Size of the part of the rescue domain already tried but not yet rescued. 
This is the sum of the sizes of all the non-trimmed, non-scraped, and
bad-sector blocks.
 <br><dt><code>non-trimmed</code><dd>Size of the part of the rescue domain pending to be trimmed. This is the
sum of the sizes of all the non-trimmed blocks.
 <br><dt><code>non-scraped</code><dd>Size of the part of the rescue domain pending to be scraped. This is the
sum of the sizes of all the non-scraped blocks.
 <br><dt><code>bad-sector</code><dd>Total error size. This is the size of the part of the rescue domain
formed by known bad sectors. The total error size is the sum of the
sizes of all the bad-sector blocks. It increases during the trimming and
scraping phases, and may decrease during the retrying phase. A sector is
not marked as bad-sector and considered part of a bad area until it has
been tried individually instead of as part of a large block read. Note
that as ddrescue retries the bad-sector blocks, the good data found may
divide them into smaller blocks, decreasing the total error size but
increasing the number of bad areas.
 <br><dt><code>bad areas</code><dd>Number of separate bad-sector blocks inside the rescue domain. 
Non-trimmed and non-scraped blocks are not considered bad areas. 
See <a href=#g_t_002d_002dmax_002dbad_002dareas>--max-bad-areas</a>.
 <br><dt><code>read errors</code><dd>Number of failed read attempts. See <a href=#g_t_002d_002dmax_002derror_002drate>--max-error-rate</a>.
 <br><dt><code>current rate</code><dd>The read rate measured during the last second.
 <br><dt><code>average rate</code><dd>The average read rate measured during the current run.
 <br><dt><code>error rate</code><dd>The read error rate measured during the last second.
 <br><dt><code>run time</code><dd>Time elapsed since the beginning of the current run.
 <br><dt><code>remaining time</code><dd>Estimated remaining time to rescue all the data in the rescue domain. 
The remaining time is calculated using the average rate of the last 30
seconds and does not take into account that some parts of the rescue
domain may be excluded from the rescue (for example with
'<samp><span class=samp>--no-trim</span></samp>'), or that some areas may be unrecoverable. Therefore it
may be very imprecise, may vary widely during the rescue, and may show a
non-zero value at the end of the rescue. In particular it may go down to
a few seconds at the end of the first pass, just to grow to hours or
days in the following passes. Such is the nature of ddrescue; the good
parts are usually recovered fast, while the rest may take a long time.
 <br><dt><code>time since last successful read</code><dd>Time elapsed since the last successful read attempt.
 </dl>
<div class=node>
<a name=Invoking-ddrescue></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Mapfile-structure>Mapfile structure</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Output>Output</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>6 Invoking ddrescue</h2>
<p><a name=index-invoking-ddrescue-6></a><a name=index-options-7></a><a name=index-usage-8></a><a name=index-version-9></a>
The format for running ddrescue is:
<pre class=example>     ddrescue [<var>options</var>] <var>infile</var> <var>outfile</var> [<var>mapfile</var>]
</pre>
 <p><var>infile</var> and <var>outfile</var> may be files, devices, or partitions. 
<var>mapfile</var> is a regular file and must be placed in an existing directory. 
If <var>mapfile</var> does not exist, ddrescue will create it. Be careful to not
specify by mistake an old <var>mapfile</var> from an unrelated rescue.
 <p>Ddrescue tries to create a backup copy of the mapfile, with the name
<var>mapfile</var>.bak, every time it is going to overwrite a fsynced
<var>mapfile</var>. See <a href=#g_t_002d_002dmapfile_002dinterval>--mapfile-interval</a>.
 <p>Always use a mapfile unless you know you won't need it. Without a mapfile,
ddrescue can't resume a rescue, only reinitiate it.
 <p>ddrescue supports the following options:
 <dl>
<dt><code>-h</code><dt><code>--help</code><dd>Print an informative help message describing the options and exit.
 <br><dt><code>-V</code><dt><code>--version</code><dd>Print the version number of ddrescue on the standard output and exit. 
This version number should be included in all bug reports.
 <p><a name=g_t_002d_002dmin_002dread_002drate></a><br></p><dt><code>-a </code><var>bytes</var><dt><code>--min-read-rate=</code><var>bytes</var><dd>Minimum read rate of good non-tried areas, in bytes per second. If the
read rate falls below this value during the first two passes of the
copying phase, ddrescue will skip ahead a variable amount depending on
rate and error histories. The skipped blocks are tried in additional
passes (before trimming).
 <p>If <var>bytes</var> is 0 (auto), the minimum read rate is recalculated every
second as (average_rate&nbsp;/&nbsp;10).
 <br></p><dt><code>-A</code><dt><code>--try-again</code><dd>Mark all non-trimmed and non-scraped blocks inside the rescue domain as
non-tried before beginning the rescue. Try this if the drive stops
responding and ddrescue immediately starts scraping failed blocks when
restarted. If '<samp><span class=samp>--retrim</span></samp>' is also specified, mark all failed blocks
inside the rescue domain as non-tried.
 <br><dt><code>-b </code><var>bytes</var><dt><code>--sector-size=</code><var>bytes</var><dd>Sector (hardware block) size of input device in bytes (usually 512 for hard
discs and 3.5" floppies, 1024 for 5.25" floppies, and 2048 for cdroms). 
Defaults to 512.
 <p>In rescue mode, any non-finished subsector that is found during the initial
read of the mapfile will be joined to its corresponding sector (if it is
also not finished), marking the whole sector with the less processed state,
so as to make sure that sub-sector data will not be discarded from a
successful read during the rescue. (A subsector is a block smaller than
sector size). Subsector joining is performed in all the mapfile, not only in
the rescue domain.
 <br></p><dt><code>-B</code><dt><code>--binary-prefixes</code><dd>Show units with binary prefixes (powers of 1024).<br>
SI prefixes (powers of 1000) are used by default. (See table below).
 <br><dt><code>-c </code><var>sectors</var><dt><code>--cluster-size=</code><var>sectors</var><dd>Number of sectors to copy at a time. Defaults to 64&nbsp;KiB&nbsp;/&nbsp;sector_size. 
Try smaller values for slow drives. The number of sectors per track (18 or
9) is a good value for floppies.
 <br><dt><code>-C</code><dt><code>--complete-only</code><dd>Limit rescue domain to the blocks listed in the <var>mapfile</var>. Don't
read new data beyond <var>mapfile</var> limits. This is useful when reading
from devices of undefined size (like raw devices), when the drive
returns an incorrect size, or when reading from a partial copy. It can
only be used after a first rescue attempt, possibly limited with the
option '<samp><span class=samp>--size</span></samp>', has produced a complete <var>mapfile</var>.
 <br><dt><code>-d</code><dt><code>--idirect</code><dd>Use direct disc access (see <a href=#Direct-disc-access>Direct disc access</a>) to read from
<var>infile</var>, bypassing the kernel cache. (Opens the file with the flag
'<samp><span class=samp>O_DIRECT</span></samp>'). Sector size must be correctly set for this to work. Not
all systems support this.
 <p>If your system does not support direct disc access, ddrescue will warn
you. If the sector size is not correctly set, an unaligned read error
will result and ddrescue will exit with status 1.
 <br></p><dt><code>-D</code><dt><code>--odirect</code><dd>Use direct disc access to write to <var>outfile</var>, bypassing the kernel
cache. (Opens the file with the flag '<samp><span class=samp>O_DIRECT</span></samp>'). Sector size must be
correctly set for this to work. Not all systems support this.
 <p>If your system does not support direct disc access, ddrescue will warn
you. If the sector size is not correctly set, a write error will result
and no data will be rescued. Some OSs have a bug that prevents them from
detecting write errors properly (or at all) on some devices if direct
disc access is not used for <var>outfile</var>.
 <p><a name=g_t_002d_002dmax_002dbad_002dareas></a><br></p><dt><code>-e [+]</code><var>n</var><dt><code>--max-bad-areas=[+]</code><var>n</var><dd>Maximum number of bad areas allowed before giving up. Defaults to
infinity. If <var>n</var> is preceded by '<samp><span class=samp>+</span></samp>' the number refers to new
bad areas found in this run, not counting those already present in the
<var>mapfile</var>.
 <p><a name=g_t_002d_002dmax_002derror_002drate></a><br></p><dt><code>-E </code><var>bytes</var><dt><code>--max-error-rate=</code><var>bytes</var><dd>Maximum rate of read errors allowed before giving up, in bytes per
second. Defaults to infinity. The rate being measured is that of
actually failed reads, so ddrescue may exit because of this rate being
exceeded even if the total error size (size of bad-sector areas) does
not change because the areas being tried are being marked as non-trimmed
or non-scraped, or are already marked as bad-sector.
 <br><dt><code>-f</code><dt><code>--force</code><dd>Force overwrite of <var>outfile</var>. Needed when <var>outfile</var> is not a
regular file, but a device or partition. This option is just a safeguard
to prevent the inadvertent destruction of partitions, and is ignored for
regular files.
 <br><dt><code>-F </code><var>types</var><dt><code>--fill-mode=</code><var>types</var><dd>Fill the blocks in <var>outfile</var> specified as any of <var>types</var> in
<var>mapfile</var>, with data read from <var>infile</var>. <var>types</var> contains
one or more of the status characters defined in the chapter Mapfile
structure (see <a href=#Mapfile-structure>Mapfile structure</a>) and an optional '<samp><span class=samp>l</span></samp>' for
sector location data. See the chapter Fill mode (see <a href=#Fill-mode>Fill mode</a>) for
a complete description of the fill mode.
 <br><dt><code>-G</code><dt><code>--generate-mode</code><dd>Generate an approximate <var>mapfile</var> from the <var>infile</var> and
<var>outfile</var> of the original rescue run. Note that you must keep the
original offset between '<samp><span class=samp>--input-position</span></samp>' and
'<samp><span class=samp>--output-position</span></samp>' of the original rescue run. See the chapter
Generate mode (see <a href=#Generate-mode>Generate mode</a>) for a complete description of the
generate mode.
 <br><dt><code>-H </code><var>file</var><dt><code>--test-mode=</code><var>file</var><dd>Builds a map of good/bad blocks using the mapfile <var>file</var> and uses it
to simulate read errors in <var>infile</var>. The blocks marked as finished
in <var>file</var> will be read normally. All other block types will be
considered read errors without even trying to read them from
<var>infile</var>. The apparent size of <var>infile</var> is truncated to the
extent of <var>file</var>. This mode is an aid in improving the algorithm of
ddrescue and is also useful to verify that ddrescue produces accurate
results in presence of read errors. Use '<samp><span class=samp>-</span></samp>' as <var>file</var> to read
from standard input.
 <br><dt><code>-i </code><var>bytes</var><dt><code>--input-position=</code><var>bytes</var><dd>Starting position of the rescue domain in <var>infile</var>, in bytes. 
Defaults to 0. This is not the point from which ddrescue starts copying. 
(For example, if you pass the option '<samp><span class=samp>--reverse</span></samp>' to ddrescue, it
starts copying from the end of the rescue domain). In fill mode it
refers to a position in the <var>infile</var> of the original rescue run. See
the chapter Fill mode (see <a href=#Fill-mode>Fill mode</a>) for details.
 <br><dt><code>-I</code><dt><code>--verify-input-size</code><dd>Compare the size of <var>infile</var> with the size calculated from the list
of blocks contained in the <var>mapfile</var>, and exit with status 1 if they
differ. This is not enabled by default because the size of some devices
can't be known in advance and because the size derived from the
<var>mapfile</var> may be incomplete, for example after doing a partial
rescue.
 <br><dt><code>-J</code><dt><code>--verify-on-error</code><dd>After every read error, read again the last good sector found and verify
that it returns the same data. Exit with status 2 if the read fails or
returns inconsistent data. Exit with status 1 if a read error happens
before a good sector is found.
 <p>This option performs one extra read after each error, wearing the drive
faster. Use it only on drives that stop responding or return garbage
data after finding errors. You may need to power cycle the drive before
restarting ddrescue.
 <br></p><dt><code>-K [</code><var>initial</var><code>][,</code><var>max</var><code>]</code><dt><code>--skip-size=[</code><var>initial</var><code>][,</code><var>max</var><code>]</code><dd>Set limits to skip size during the copying phase. At least one of
<var>initial</var> or <var>max</var> must be specified. <var>initial</var> is the size
to skip on the first read error or slow read, in bytes. <var>max</var> is the
maximum size to skip. The values given will be rounded to the next
multiple of sector size. The skip size will be doubled for each read
error or slow read until it reaches <var>max</var> or, if <var>max</var> is
omitted, 1% of the size of <var>infile</var>, and will be reset to
<var>initial</var> when good data are found. Valid values range from 64&nbsp;KiB
to 1&nbsp;EiB. <var>initial</var> defaults to <var>infile_size</var>&nbsp;/&nbsp;100_000
with a minimum value of 64&nbsp;KiB. An <var>initial</var> value of 0 disables
skipping entirely.
 <p>If ddrescue is having difficulties skipping away from a large area with
scattered errors, or if the device has large bad areas at regular
intervals, you may increase the initial skip size with this option. 
Inversely, if ddrescue is skipping too much, leaving large non-tried
areas behind each error (which will be read later in the usually slower
backwards direction), you may reduce the maximum skip size, or disable
skipping.
 <p>'<samp><span class=samp>--skip-size</span></samp>' is independent from '<samp><span class=samp>--cluster-size</span></samp>'. The size
to skip is calculated from the end of the block that just failed.
 <br></p><dt><code>-L</code><dt><code>--loose-domain</code><dd>Accept an incomplete synthetic (user fabricated) domain mapfile or
test-mode mapfile, and fill the gaps in the list of data blocks with
non-tried blocks. The blocks in the mapfile must be strictly ascending
and non-overlapping, but they don't need to be contiguous. This option
allows making quick edits to a mapfile without all the size calculations
involved in making all data blocks contiguous again.
 <p><a name=g_t_002d_002ddomain_002dmapfile></a><br></p><dt><code>-m </code><var>file</var><dt><code>--domain-mapfile=</code><var>file</var><dd>Restrict the rescue domain to the blocks marked as finished in the
mapfile <var>file</var>. This is useful for merging partially recovered
images of backups, or if the destination drive fails during the rescue. 
Use '<samp><span class=samp>-</span></samp>' as <var>file</var> to read the domain mapfile from standard input. 
Specialized tools like ddrutility or partclone can produce a domain
mapfile listing all the used blocks in a partition, making the rescue
more efficient.
 <br><dt><code>-M</code><dt><code>--retrim</code><dd>Mark all failed blocks inside the rescue domain as non-trimmed before
beginning the rescue. The effect is similar to '<samp><span class=samp>--retry-passes=1</span></samp>',
but the bad sectors are tried in a different order, making perhaps
possible to rescue some of them.
 <br><dt><code>-n</code><dt><code>--no-scrape</code><dd>Skip the scraping phase. Avoids spending a lot of time trying to rescue
the most difficult parts of the file.
 <br><dt><code>-N</code><dt><code>--no-trim</code><dd>Skip the trimming phase. Especially useful in the first parts of a
multi-part rescue.
 <br><dt><code>-o </code><var>bytes</var><dt><code>--output-position=</code><var>bytes</var><dd>Starting position of the image of the rescue domain in <var>outfile</var>, in
bytes. Defaults to '<samp><span class=samp>--input-position</span></samp>'. The bytes below <var>bytes</var>
aren't touched if they exist and truncation is not requested. Else they
are set to 0.
 <br><dt><code>-O</code><dt><code>--reopen-on-error</code><dd>Close <var>infile</var> and then reopen it after every read error encountered
during the copying phase. If '<samp><span class=samp>--min-read-rate</span></samp>' is set, also close
and reopen <var>infile</var> after every slow read encountered during the
first two passes of the copying phase. Use this option if you notice a
permanent drop in transfer rate after finding read errors or slow areas. 
But be warned that most probably the slowing-down is intentionally
caused by the kernel in an attempt to increase the probability of
reading data from the device.
 <br><dt><code>-p</code><dt><code>--preallocate</code><dd>Preallocate space on disc for <var>outfile</var>. Only space for regular files
can be preallocated. If preallocation succeeds, rescue will not fail due to
lack of free space on disc. If ddrescue can't determine the size to
preallocate, you may need to specify it with some combination of the options
'<samp><span class=samp>--input-position</span></samp>', '<samp><span class=samp>--output-position</span></samp>', '<samp><span class=samp>--size</span></samp>', and
'<samp><span class=samp>--domain-mapfile</span></samp>'.
 <br><dt><code>-P[</code><var>lines</var><code>]</code><dt><code>--data-preview[=</code><var>lines</var><code>]</code><dd>Show <var>lines</var> lines of the latest data read in '<samp><span class=samp>16-byte&nbsp;hex&nbsp;+&nbsp;ASCII</span></samp>' format. Valid values for <var>lines</var> range from 1 to 32. If
<var>lines</var> is omitted, a default value of 3 is used.
 <br><dt><code>-q</code><dt><code>--quiet</code><dd>Quiet operation. Suppress all messages.
 <br><dt><code>-r </code><var>n</var><dt><code>--retry-passes=</code><var>n</var><dd>Exit after the given number of retry passes. Defaults to 0. -1 means
infinity. Every bad sector is tried only once in each pass. To retry bad
sectors detected on a previous run, you must specify a non-zero number
of retry passes.
 <br><dt><code>-R</code><dt><code>--reverse</code><dd>Reverse the direction of all passes (copying, trimming, scraping, and
retrying). Every pass that is normally run forwards will now be run
backwards, and vice versa. '<samp><span class=samp>--reverse</span></samp>' does not modify the size of
the blocks copied during each phase, just the order in which they are
tried.
 <br><dt><code>-s </code><var>bytes</var><dt><code>--size=</code><var>bytes</var><dd>Maximum size of the rescue domain in bytes. It limits the amount of
input data to be copied. If ddrescue can't determine the size of the
input file, you may need to specify it with this option. Note that this
option does not specify the size of the resulting <var>outfile</var>. For
example, the following command creates an <var>outfile</var> 300 bytes long,
but only writes data on the last 200 bytes:
 <pre class=example>          ddrescue -i 100 -s 200 infile outfile mapfile
</pre>
 <br><dt><code>-S</code><dt><code>--sparse</code><dd>Use sparse writes for <var>outfile</var>. (The blocks of zeros are not
actually allocated on disc). May save a lot of disc space in some cases. 
Not all systems support this. Only regular files can be sparse.
 <br><dt><code>-t</code><dt><code>--truncate</code><dd>Truncate <var>outfile</var> to zero size before writing to it. Only works for
regular files, not for drives or partitions.
 <br><dt><code>-T </code><var>interval</var><dt><code>--timeout=</code><var>interval</var><dd>Maximum time since last successful read allowed before giving up. 
Defaults to infinity. <var>interval</var> is an integer or rational number
(like 1.5 or 1/2) optionally followed by one of '<samp><span class=samp>s</span></samp>', '<samp><span class=samp>m</span></samp>',
'<samp><span class=samp>h</span></samp>', or '<samp><span class=samp>d</span></samp>', meaning seconds, minutes, hours, and days
respectively. If no unit is specified, it defaults to seconds. 
<var>interval</var> has a resolution of one second; fractions of a second are
not allowed.
 <br><dt><code>-u</code><dt><code>--unidirectional</code><dd>Run all passes in the same direction. Forwards by default, or backwards
if the option '<samp><span class=samp>--reverse</span></samp>' is also given.
 <br><dt><code>-v</code><dt><code>--verbose</code><dd>Verbose mode. Further -v's (up to 4) increase the verbosity level. 
Some large numbers in messages (like device sizes) are printed in groups of
3 digits separated by underscore characters to make them more readable.
 <br><dt><code>-w</code><dt><code>--ignore-write-errors</code><dd>Make fill mode ignore write errors. This is useful to avoid ddrescue
exiting because of new bad sectors developing while wiping the good
sectors of a failing drive. Fill mode normally writes to <var>outfile</var>
one cluster at a time. With this option, after the first write error is
found in an area, the rest of that area is filled sector by sector.
 <p>Note that in rescue mode a write error is fatal, which means that the
rescue needs to be repeated or else <var>outfile</var> needs to be copied to
a third drive using <var>mapfile</var> as domain (see <a href=#g_t_002d_002ddomain_002dmapfile>--domain-mapfile</a>).
 <br></p><dt><code>-x </code><var>bytes</var><dt><code>--extend-outfile=</code><var>bytes</var><dd>Extend the size of <var>outfile</var> to make it at least <var>bytes</var> long. 
If the size of <var>outfile</var> is already equal or longer than <var>bytes</var>,
then this option does nothing. Use this option to guarantee a minimum
size for <var>outfile</var>. Only regular files can be extended.
 <br><dt><code>-X </code><var>n</var><dt><code>--max-read-errors=</code><var>n</var><dd>Maximum number of read errors allowed before giving up. Defaults to
infinity. Exit with status 1 if more than <var>n</var> read errors are
encountered. '<samp><span class=samp>--max-read-errors=0</span></samp>' is similar but different to
'<samp><span class=samp>--timeout=0</span></samp>', which waits until the screen status is refreshed (at
least 1 second). If there is at least one successful read per second,
'<samp><span class=samp>--timeout=0</span></samp>' does not make ddrescue to exit.
 <p>'<samp><span class=samp>--max-read-errors=0</span></samp>' is also similar but different to
'<samp><span class=samp>--max-bad-areas=+0</span></samp>', which exits when a new bad area is found. If
the read errors are adjacent to existing bad areas, no new bad areas are
produced (just enlarged), and '<samp><span class=samp>--max-bad-areas=+0</span></samp>' does not make
ddrescue to exit.
 <br></p><dt><code>-y</code><dt><code>--synchronous</code><dd>Use synchronous writes for <var>outfile</var>. (Issue a fsync call after
every write). May be useful when forcing the drive to remap its bad
sectors.
 <br><dt><code>-Z </code><var>bytes</var><dt><code>--max-read-rate=</code><var>bytes</var><dd>Maximum read rate, in bytes per second. If <var>bytes</var> is too small, the
actual read rate is rounded up to the equivalent of a whole number of
cluster reads per second. Use this option to limit the bandwidth used by
ddrescue, for example when recovering over a network.
 <br><dt><code>--ask</code><dd>Ask for user confirmation before starting the copy. If the first letter
of the answer is '<samp><span class=samp>y</span></samp>', ddrescue starts copying. Else it exits with
status 1.<br>
If they can be obtained, ddrescue shows the model and serial number of
the input and output devices. Ddrescue also shows the size in bytes of
the corresponding file or device if it exists. The format used is
[<var>model</var>::<var>serial_number</var>]&nbsp;(<var>size</var>)
 <br><dt><code>--command-mode</code><dd>Read commands from the standard input and execute them, copying parts of the
input file on demand. Command line arguments controling the display (like
'<samp><span class=samp>--data-preview</span></samp>') or the automatic algorithm (like '<samp><span class=samp>--max-errors</span></samp>'
or '<samp><span class=samp>--reverse</span></samp>') have no effect in command mode. See <a href=#Command-mode>Command mode</a>,
for a complete description of the command mode.
 <br><dt><code>--cpass=</code><var>range</var><dd>Select what pass(es) to run during the copying phase. Valid pass values
range from 1 to 5. To run only the given pass(es), specify also
'<samp><span class=samp>--no-trim</span></samp>' and '<samp><span class=samp>--no-scrape</span></samp>'. '<samp><span class=samp>--cpass=0</span></samp>' skips the
copying phase entirely.
 <p><table summary><tbody><tr align=left><td valign=top>Examples of <var>range</var> <td valign=top>Passes run
<br><tr align=left><td valign=top>1 <td valign=top>1
<br><tr align=left><td valign=top>1,2,3 <td valign=top>1, 2, 3
<br><tr align=left><td valign=top>2-4 <td valign=top>2, 3, 4
<br><tr align=left><td valign=top>1,3-5 <td valign=top>1, 3, 4, 5
<br><tr align=left><td valign=top>1-3,5 <td valign=top>1, 2, 3, 5
 <br></table>
 <br></p><dt><code>--delay-slow=</code><var>interval</var><dd>Initial delay before ddrescue starts checking for slow reads. Defaults
to 30 seconds. <var>interval</var> is formatted as in the option
'<samp><span class=samp>--timeout</span></samp>' above.
 <br><dt><code>--log-events=</code><var>file</var><dd>Log all significant events (start of each pass and end of run) in
<var>file</var>. If <var>file</var> already exists, the new events are appended at
the end of <var>file</var>. For each event a line is printed containing a
time stamp, the percentage rescued, and a message describing the event. 
The '<samp><span class=samp>end of run</span></samp>' line also contains the current position and
status. If ddrescue exits because of an error or interruption, the cause
is also logged in <var>file</var>.
 <br><dt><code>--log-rates=</code><var>file</var><dd>Log rates and error sizes every second in <var>file</var>. If <var>file</var>
already exists, it will be overwritten. Every time the screen is updated
with new details, some of those details (time, input position, current
and average rates, number of bad areas, and total error size) are written
to <var>file</var> in a format usable by plotting utilities like gnuplot. 
This allows a posterior analysis of the drive to see if it has any weak
zones (areas where the transfer rate drops well below the sustained
average).
 <br><dt><code>--log-reads=</code><var>file</var><dd>Log all read operations in <var>file</var>. If <var>file</var> already exists, it
will be overwritten. Every read attempt and its result (position, size,
copied size, and error size) is written to <var>file</var>. (The position
written is always the beginning of the block tried, even if reading
backwards). A line is also written at the beginning of each phase
(copying, trimming, scraping, and retrying). Finally, a line with a time
mark is written every second (unless the read takes more time). Use this
option with caution because <var>file</var> may become very large very
quickly. Use lzip to compress <var>file</var> if you need to store or
transmit it.
 <p><a name=g_t_002d_002dmapfile_002dinterval></a><br></p><dt><code>--mapfile-interval=[</code><var>save_interval</var><code>][,</code><var>sync_interval</var><code>]</code><dd>Change the interval at which ddrescue saves and fsyncs the <var>mapfile</var>. At
least one of <var>save_interval</var> or <var>sync_interval</var> must be specified. A
<var>save_interval</var> of -1 chooses the default automatic interval (from 30
seconds to 5 minutes depending on mapfile size). A <var>save_interval</var> of 0
saves the <var>mapfile</var> after every read (use with caution). 
<var>sync_interval</var> is the interval between fsync calls. Default
<var>sync_interval</var> is 5 minutes. Minimum <var>sync_interval</var> is 5 seconds. 
<var>sync_interval</var> must be greater or equal than <var>save_interval</var>. 
Intervals are formatted as in the option '<samp><span class=samp>--timeout</span></samp>' above.
 <p>In practice, fsyncs are a subset of saves. I.e., some of the times when the
<var>mapfile</var> is saved, it is also fsync'ed. Therefore,
'<samp><span class=samp>--mapfile-interval=30,45</span></samp>' is really '<samp><span class=samp>--mapfile-interval=30,60</span></samp>'. 
The time needed to write the <var>mapfile</var> is excluded from the mapfile save
and sync intervals. (Some mapfiles may take several seconds to write).
 <br></p><dt><code>--max-slow-reads=</code><var>n</var><dd>Maximum number of slow reads allowed before giving up. Defaults to
infinity. Exit with status 1 if more than <var>n</var> slow reads are
encountered during the first two passes of the copying phase. Only works
if a minimum read rate has been set with '<samp><span class=samp>--min-read-rate</span></samp>'.
 <br><dt><code>--pause-on-error=</code><var>interval</var><dd>Time to wait after each read error or slow read. Defaults to 0. 
<var>interval</var> is formatted as in the option '<samp><span class=samp>--timeout</span></samp>' above. If
<var>interval</var> begins with '<samp><span class=samp>s</span></samp>', the pause is simulated and
<var>interval</var> can be smaller than one second; the time displayed is
increased by <var>interval</var> but without performing any pause. Pause
simulation can be useful in combination with '<samp><span class=samp>--test-mode</span></samp>' for
testing purposes.
 <br><dt><code>--pause-on-pass=</code><var>interval</var><dd>Time to wait between passes. Defaults to 0. <var>interval</var> is formatted
as in the option '<samp><span class=samp>--timeout</span></samp>' above.
 <br><dt><code>--reset-slow</code><dd>Reset the slow reads counter every time the read rate reaches or
surpasses '<samp><span class=samp>--min-read-rate</span></samp>'. With this option, ddrescue only exits
after the read rate has remained below '<samp><span class=samp>--min-read-rate</span></samp>' for at
least as many seconds as the argument given to '<samp><span class=samp>--max-slow-reads</span></samp>'.
 <br><dt><code>--same-file</code><dd>Allow <var>infile</var> and <var>outfile</var> to be the same file or device. This
may be used to test the writing ability of a drive. It may also be used
to copy part of a file to another location inside or beyond the end of
the same file by setting different values for '<samp><span class=samp>--input-position</span></samp>'
and '<samp><span class=samp>--output-position</span></samp>'. If the data to be copied overlap with the
destination, the right copying direction must be chosen to avoid
overwriting the overlapping part before it is copied.
 </dl>
 <p>Numbers given as arguments to options (positions, sizes, rates, etc) may
be expressed as decimal, hexadecimal, or octal values (using the same
syntax as integer constants in C++), and may be followed by a multiplier
and an optional '<samp><span class=samp>B</span></samp>' for "byte". The '<samp><span class=samp>s</span></samp>' multiplier may be
appended to any of the other multipliers. For example, '<samp><span class=samp>ks</span></samp>' means
kilosectors (1000&nbsp;*&nbsp;sector_size), and '<samp><span class=samp>Kis</span></samp>' means kibisectors
(1024&nbsp;*&nbsp;sector_size).
 <p>Table of SI and binary prefixes (unit multipliers):
 <p><table summary><tbody><tr align=left><td valign=top>Prefix <td valign=top>Value <td valign=top>| <td valign=top>Prefix <td valign=top>Value
<br><tr align=left><td valign=top>s <td valign=top>sectors <td valign=top>| <td valign=top><td valign=top>
<br><tr align=left><td valign=top>k <td valign=top>kilobyte (10^3 = 1000) <td valign=top>| <td valign=top>Ki <td valign=top>kibibyte (2^10 = 1024)
<br><tr align=left><td valign=top>M <td valign=top>megabyte (10^6) <td valign=top>| <td valign=top>Mi <td valign=top>mebibyte (2^20)
<br><tr align=left><td valign=top>G <td valign=top>gigabyte (10^9) <td valign=top>| <td valign=top>Gi <td valign=top>gibibyte (2^30)
<br><tr align=left><td valign=top>T <td valign=top>terabyte (10^12) <td valign=top>| <td valign=top>Ti <td valign=top>tebibyte (2^40)
<br><tr align=left><td valign=top>P <td valign=top>petabyte (10^15) <td valign=top>| <td valign=top>Pi <td valign=top>pebibyte (2^50)
<br><tr align=left><td valign=top>E <td valign=top>exabyte (10^18) <td valign=top>| <td valign=top>Ei <td valign=top>exbibyte (2^60)
<br><tr align=left><td valign=top>Z <td valign=top>zettabyte (10^21) <td valign=top>| <td valign=top>Zi <td valign=top>zebibyte (2^70)
<br><tr align=left><td valign=top>Y <td valign=top>yottabyte (10^24) <td valign=top>| <td valign=top>Yi <td valign=top>yobibyte (2^80)
 <br></table>
 <pre class=sp></pre>
Exit status: 0 for a normal exit, 1 for environmental problems (file not
found, invalid flags, I/O errors, etc), 2 to indicate a corrupt or
invalid input file, 3 for an internal consistency error (eg, bug) which
caused ddrescue to panic.
 <p>If ddrescue is interrupted by a signal, it updates <var>mapfile</var> and
then terminates by raising the signal received.
<div class=node>
<a name=Mapfile-structure></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Emergency-save>Emergency save</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Invoking-ddrescue>Invoking ddrescue</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>7 Mapfile structure</h2>
<p><a name=index-mapfile-structure-10></a>
NOTE: In versions of ddrescue prior to 1.20 the mapfile was called
'<samp><span class=samp>logfile</span></samp>'. The format is the same; only the name has changed.
 <p>The mapfile is a text file easy to read and edit. It is formed by three
parts, the heading comments, the status line, and the list of data
blocks. The character '<samp><span class=samp>#</span></samp>' at begin of line or after whitespace
starts a comment that extends to the end of the line.
 <p>The heading comments contain the version of ddrescue or ddrescuelog that
created the mapfile, the command line used, and the time when the
program started. If the mapfile was created by ddrescue it will also
contain the current time when the mapfile was saved and a copy of the
status message from the screen describing the operation being performed
(copying, trimming, finished, etc). They are intended as information for
the user.
 <p>The first non-comment line is the status line. It contains a
non-negative integer, a status character, and a positive decimal
integer. The first integer is the position being tried in the input
file. (The beginning of the block being tried in a forward pass or the
end of the block in a backward pass). The status character is one of
these:
 <p><table summary><tbody><tr align=left><td valign=top>Character <td valign=top>Meaning
<br><tr align=left><td valign=top>'?' <td valign=top>copying non-tried blocks
<br><tr align=left><td valign=top>'*' <td valign=top>trimming non-trimmed blocks
<br><tr align=left><td valign=top>'/' <td valign=top>scraping non-scraped blocks
<br><tr align=left><td valign=top>'-' <td valign=top>retrying bad sectors
<br><tr align=left><td valign=top>'F' <td valign=top>filling specified blocks
<br><tr align=left><td valign=top>'G' <td valign=top>generating approximate mapfile
<br><tr align=left><td valign=top>'+' <td valign=top>finished
 <br></table>
 <p>Finally, the last integer is the number of the current pass in the
current phase. The status line allows ddrescue to resume the copying
phase instead of restarting it from pass 1. It also allows the retrying
phase to resume in the same direction it was interrupted.
 <p>The blocks in the list of data blocks must be contiguous and
non-overlapping.
 <p>Every line in the list of data blocks describes a block of data. It
contains 2 non-negative integers and a status character. The first
integer is the starting position of the block in the input file, the
second integer is the size (in bytes) of the block. The status character
is one of these:
 <p><table summary><tbody><tr align=left><td valign=top>Character <td valign=top>Meaning
<br><tr align=left><td valign=top>'?' <td valign=top>non-tried block
<br><tr align=left><td valign=top>'*' <td valign=top>failed block non-trimmed
<br><tr align=left><td valign=top>'/' <td valign=top>failed block non-scraped
<br><tr align=left><td valign=top>'-' <td valign=top>failed block bad-sector(s)
<br><tr align=left><td valign=top>'+' <td valign=top>finished block
 <br></table>
<p class=noindent>And here is an example mapfile:
<pre class=example>     # Mapfile. Created by GNU ddrescue version 1.25
     # Command line: ddrescue -d -c18 /dev/fd0 fdimage mapfile
     # Start time:   2015-07-21 09:37:44
     # Current time: 2015-07-21 09:38:19
     # Copying non-tried blocks... Pass 1 (forwards)
     # current_pos  current_status  current_pass
     0x00120000     ?               1
     #      pos        size  status
     0x00000000  0x00117000  +
     0x00117000  0x00000200  -
     0x00117200  0x00001000  /
     0x00118200  0x00007E00  *
     0x00120000  0x00048000  ?
</pre>
 <p>If you edit the file, you may use decimal, hexadecimal, or octal values,
using the same syntax as integer constants in C++, except for
current_pass, which must be a decimal integer.
<div class=node>
<a name=Emergency-save></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Optical-media>Optical media</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Mapfile-structure>Mapfile structure</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>8 Saving the mapfile in case of trouble</h2>
<p><a name=index-emergency-save-11></a>
The mapfile is an essential part of ddrescue's effectiveness. Without a
mapfile, ddrescue can't resume a rescue, only reinitiate it. Given that
a difficult rescue may take days to complete, it would be a serious
drawback if the mapfile were lost because of a solvable problem like a
lack of space on the device the mapfile is written to.
 <p>In case of trouble writing the mapfile, ddrescue will print a message
like this:
<pre class=example>     Error writing mapfile '<var>mapfile</var>': No space left on device
     Fix the problem and press ENTER to retry,
                          or E+ENTER for an emergency save and exit,
                          or Q+ENTER to abort.
</pre>
 <p>You may try to fix the problem, for example deleting some files to make
room for the mapfile, and press &lt;Return&gt; to retry.
 <p>If the problem can't be fixed, you may press &lt;e&gt; followed by
&lt;Return&gt; to try an emergency save and exit. Ddrescue will try to
write the mapfile to the file <samp><span class=file>ddrescue.map</span></samp> in the current
directory or, if this fails, to <samp><span class=file>$HOME/ddrescue.map</span></samp>. If the
mapfile is written successfully, ddrescue will exit with status 1. Else
it will print the above message again.
 <p>Or you may press &lt;q&gt; followed by &lt;Return&gt; to quit and exit with
status 1. In this case the contents of the mapfile will be lost.
<div class=node>
<a name=Optical-media></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Examples>Examples</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Emergency-save>Emergency save</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>9 Copying CD-ROMs and DVDs</h2>
<p><a name=index-optical-media-12></a>
Ddrescue may be better than dd for copying recordable CD-ROMs because
the two lead out sectors at the end of some of them may cause a read
error that prevents the whole last record from being copied by dd,
potentially losing data. Also dd may create an image larger than the
original if the '<samp><span class=samp>sync</span></samp>' conversion and a block size larger than the
sector size are specified.
 <p>In the special case of reading CD-ROMs (but not DVDs), the specialized
tool dvdisaster may be a better option than ddrescue for recovering data
because dvdisaster can read and analyze raw CD sectors, which ddrescue
can't.
 <p>Recordable CD and DVD media keep their data only for a finite time
(typically for some years). After that time, data loss develops slowly with
read errors growing from the outer media region towards the inside. It is a
good idea to make two (or more) copies of every important CD-ROM/DVD you
burn so that you can later recover them with ddrescue.
 <p>If you have only one copy of a CD-ROM or DVD that fails when being
copied, and if you have access to multiple optical media drives, you
have a better chance of recovering the bad sectors since one drive may
fail to read a particular sector, but another drive might be able to
squeeze the data out of it, depending on the laser frequency and the
sensitivity of the laser-sensor that reads the reflected laser light.
 <pre class=sp></pre>
Example 1: Rescue a CD-ROM in /dev/cdrom.
<pre class=example>     ddrescue -n -b2048 /dev/cdrom cdimage mapfile
     ddrescue -d -r1 -b2048 /dev/cdrom cdimage mapfile
       (if bad-sector size is zero, cdimage now contains a complete image
        of the CD-ROM and you can write it to a blank CD-ROM)
</pre>
 <pre class=sp></pre>
Example 2: Rescue a CD-ROM in /dev/cdrom from two copies.
<pre class=example>     ddrescue -n -b2048 /dev/cdrom cdimage mapfile
     ddrescue -d -b2048 /dev/cdrom cdimage mapfile
       (insert second copy in the CD drive)
     ddrescue -d -r1 -b2048 /dev/cdrom cdimage mapfile
       (if bad-sector size is zero, cdimage now contains a complete image
        of the CD-ROM and you can write it to a blank CD-ROM)
</pre>
 <pre class=sp></pre>
Example 3: Rescue a CD-ROM in /dev/cdrom using two CD drives from two
different computers, writing the image into an USB drive mounted on
/mnt/mem.
<pre class=example>     ddrescue -n -b2048 /dev/cdrom /mnt/mem/cdimage /mnt/mem/mapfile
     ddrescue -d -r1 -b2048 /dev/cdrom /mnt/mem/cdimage /mnt/mem/mapfile
       (umount the USB drive and move both USB drive and CD-ROM to second
        computer)
     ddrescue -d -r1 -b2048 /dev/cdrom /mnt/mem/cdimage /mnt/mem/mapfile
       (if bad-sector size is zero, /mnt/mem/cdimage now contains a complete
        image of the CD-ROM and you can write it to a blank CD-ROM)
</pre>
 <pre class=sp></pre>
Example 4: Merge the partially recovered images of 3 identical DVDs
using their mapfiles as domain mapfiles.
<pre class=example>     ddrescue -m mapfile1 dvdimage1 dvdimage mapfile
     ddrescue -m mapfile2 dvdimage2 dvdimage mapfile
     ddrescue -m mapfile3 dvdimage3 dvdimage mapfile
       (if bad-sector size is zero, dvdimage now contains a complete image
        of the DVD and you can write it to a blank DVD)
</pre>
 <pre class=sp></pre>
<a name=lziprecover_002dexample></a>Example 5: Rescue a lzip compressed backup from two copies on CD-ROM
with error-checked merging of copies. 
See the
<a href=http://www.nongnu.org/lzip/manual/lziprecover_manual.html>lziprecover manual</a>
for details about lziprecover.
<pre class=example>     ddrescue -d -r1 -b2048 /dev/cdrom cdimage1 mapfile1
     mount -t iso9660 -o loop,ro cdimage1 /mnt/cdimage
     cp /mnt/cdimage/backup.tar.lz rescued1.tar.lz
     umount /mnt/cdimage
       (insert second copy in the CD drive)
     ddrescue -d -r1 -b2048 /dev/cdrom cdimage2 mapfile2
     mount -t iso9660 -o loop,ro cdimage2 /mnt/cdimage
     cp /mnt/cdimage/backup.tar.lz rescued2.tar.lz
     umount /mnt/cdimage
     lziprecover -m -v -o backup.tar.lz rescued1.tar.lz rescued2.tar.lz
       Input files merged successfully.
     lziprecover -tv backup.tar.lz
       backup.tar.lz: ok
</pre>
 <div class=node>
<a name=Examples></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Direct-disc-access>Direct disc access</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Optical-media>Optical media</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>10 A small tutorial with examples</h2>
<p><a name=index-examples-13></a>
This tutorial is for those already able to use the dd command. If you
don't know what dd is, better search the net for some introductory
material about dd and GNU ddrescue first.
 <p>A failing drive tends to develop more and more errors as time passes. 
Because of this, you should rescue the data from a drive as soon as you
notice the first error. Be diligent because every time a physically
damaged drive powers up and is able to output some data, it may be the
very last time that it ever will.
 <p>You should make a copy of the failing drive with ddrescue, and then try
to repair the copy. If your data are really important, use the first copy
as a master for a second copy, and try to repair the second copy. If
something goes wrong, you have the master intact to try again.
 <p>If you are trying to rescue a whole partition, first repair the copy
with e2fsck or some other tool appropriate for the type of partition you
are trying to rescue, then mount the repaired copy somewhere and try to
recover the files in it.
 <p>If the drive is so damaged that the file system in the rescued partition
can't be repaired or mounted, you will have to browse the rescued data
with an hex editor and extract the desired parts by hand, or use a file
recovery tool like photorec.
 <p>If the partition table is damaged, you may try to rescue the whole disc,
then try to repair the partition table and the partitions on the copy.
 <p>If the damaged drive is not listed in /dev, then you cannot rescue it. 
At least not with ddrescue.
 <p>See <a href=#Optical-media>Optical media</a>, for rescue examples of CD-ROMs and DVDs.
 <pre class=sp></pre>
Example 1: Fully automatic rescue of a whole disc with two ext2
partitions in /dev/sda to /dev/sdb.<br>
Note: you don't need to partition /dev/sdb beforehand, but if the
partition table on /dev/sda is damaged, you'll need to recreate it
somehow on /dev/sdb.
<pre class=example>     ddrescue -f -r3 /dev/sda /dev/sdb mapfile
     fdisk /dev/sdb
     e2fsck -v -f /dev/sdb1
     e2fsck -v -f /dev/sdb2
</pre>
 <pre class=sp></pre>
Example 2: Rescue an ext2 partition in /dev/sda2 to /dev/sdb2.<br>
Note: you need to create the sdb2 partition with fdisk first. sdb2
should be of appropriate type and size.
<pre class=example>     ddrescue -f -n /dev/sda2 /dev/sdb2 mapfile
     ddrescue -d -f -r3 /dev/sda2 /dev/sdb2 mapfile
     e2fsck -v -f /dev/sdb2
     mount -t ext2 -o ro /dev/sdb2 /mnt
       (read rescued files from /mnt)
</pre>
 <pre class=sp></pre>
Example 3: While rescuing the whole drive /dev/sda to /dev/sdb, /dev/sda
freezes up at position 12345678.
<pre class=example>     ddrescue -f /dev/sda /dev/sdb mapfile         # /dev/sda freezes here
       (restart /dev/sda or reboot computer)
       (restart copy at a safe distance from the troubled sector)
     ddrescue -f -i 12350000 /dev/sda /dev/sdb mapfile
       (then copy backwards down to the troubled sector)
     ddrescue -f -R /dev/sda /dev/sdb mapfile
</pre>
 <pre class=sp></pre>
Example 4: While rescuing the whole drive /dev/sda to /dev/sdb, /dev/sdb
fails and you have to rescue data to a third drive, /dev/sdc.
<pre class=example>     ddrescue -f -n /dev/sda /dev/sdb mapfile1       # /dev/sdb fails here
     ddrescue -f -m mapfile1 /dev/sdb /dev/sdc mapfile2
     ddrescue -f -n /dev/sda /dev/sdc mapfile2
     ddrescue -d -f -r3 /dev/sda /dev/sdc mapfile2
</pre>
 <pre class=sp></pre>
Example 5: While rescuing a partition in /dev/sda1 to the file hdimage,
/dev/sda1 stops responding and begins returning read errors, causing
ddrescue to mark the rest of the partition as non-scraped.
<pre class=example>     ddrescue -n /dev/sda1 hdimage mapfile          # /dev/sda1 fails here
       (restart /dev/sda or reboot computer)
     ddrescue -n -A -i&lt;pos&gt; -O /dev/sda1 hdimage mapfile
       (if /dev/sda1 fails again, restart /dev/sda or reboot computer and
        then repeat the above command as many times as needed until it
        succeeds. &lt;pos&gt; is the position where the drive stopped responding)
     ddrescue -d -r3 /dev/sda1 hdimage mapfile
</pre>
 <pre class=sp></pre>
Example 6: While rescuing a partition in /dev/sda1 to the file hdimage,
sda1 disappears from /dev.
<pre class=example>     ddrescue -n /dev/sda1 hdimage mapfile          # /dev/sda1 fails here
       (restart /dev/sda or reboot computer and then repeat the above
        command as many times as needed until it succeeds)
     ddrescue -d -r3 /dev/sda1 hdimage mapfile
</pre>
 <pre class=sp></pre>
Example 7: While rescuing a partition in /dev/sda1 to the file hdimage,
the partition table of /dev/sda becomes unreadable and the OS no longer
shows sda1 in /dev. The solution is to shift the mapfile and read the
rest of the partition sda1 from /dev/sda. 
Note: you need to know the offset of the partition sda1 in the drive sda
and the size of sda1.
<pre class=example>     ddrescue /dev/sda1 hdimage mapfile       # partition table fails here
     ddrescuelog --shift -o&lt;offset&gt; mapfile &gt; shifted_mapfile
     ddrescue -i&lt;offset&gt; -o0 -s&lt;size&gt; /dev/sda hdimage shifted_mapfile
</pre>
 <pre class=sp></pre>
Example 8: After rescuing a partition in /dev/sda1 to the file hdimage,
expand hdimage to copy the whole drive in /dev/sda without recopying the
already copied partition /dev/sda1. The solution is to shift the
mapfile, move the data of sda1 to its final position in hdimage, and
then read the rest of the data from /dev/sda. 
Note: you need to know the offset of the partition sda1 in the drive sda
and the size of sda1.
<pre class=example>     ddrescue /dev/sda1 hdimage mapfile             # rescue partition
     ddrescuelog --shift -o&lt;offset&gt; mapfile &gt; shifted_mapfile
     ddrescue --same-file -o&lt;offset&gt; -s&lt;size&gt; --reverse hdimage hdimage
     ddrescue /dev/sda hdimage shifted_mapfile      # rescue rest of drive
</pre>
 <div class=node>
<a name=Direct-disc-access></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Command-mode>Command mode</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Examples>Examples</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>11 Direct disc access</h2>
<p><a name=index-direct-disc-access-14></a><a name=index-raw-devices-15></a>
If you notice that the positions and sizes in <var>mapfile</var> are always
multiples of the sector size, maybe your kernel is caching the disc
accesses and grouping them. In this case you may want to use direct disc
access for <var>infile</var>, or read from a raw device, to bypass the kernel
cache and rescue more of your data.
 <p>NOTE! Sector size must be correctly set with the option '<samp><span class=samp>--sector-size</span></samp>'
for direct disc access to work.
 <p>NOTE: Direct disc access can copy arbitrary domains by reading whole
sectors and then writing only the requested part. This is the only case
where ddrescue will try to read data outside of the rescue domain.
 <p>Try the option '<samp><span class=samp>--idirect</span></samp>' first. If direct disc access is not
available in your system, try raw devices. Read your system
documentation to find how to bind a raw device to a regular block
device. Some OSs provide raw access through especial device names, like
/dev/rdisk.
 <p>Ddrescue aligns its I/O buffer to the sector size so that it can be used for
direct disc access or to read from raw devices. For efficiency reasons, also
aligns it to the memory page size if page size is a multiple of sector size. 
On some systems, ddrescue can't determine the size of a raw device, so an
explicit '<samp><span class=samp>--size</span></samp>' or '<samp><span class=samp>--complete-only</span></samp>' option may be needed.
 <p>Using direct disc access, or reading from a raw device, may be slower or
faster than normal cached reading depending on your OS and hardware. In
case it is slower you may want to make a first pass using normal cached
reads and use direct disc access, or a raw device, only to recover the
good sectors inside the failed blocks.
 <pre class=sp></pre>
Example 1: using direct disc access.
<pre class=example>     ddrescue -f -n /dev/sdb1 /dev/sdc1 mapfile
     ddrescue -d -f -r3 /dev/sdb1 /dev/sdc1 mapfile
     e2fsck -v -f /dev/sdc1
     mount -t ext2 -o ro /dev/sdc1 /mnt
</pre>
 <pre class=sp></pre>
Example 2: using a raw device.
<pre class=example>     raw /dev/raw/raw1 /dev/sdb1
     ddrescue -f -n /dev/sdb1 /dev/sdc1 mapfile
     ddrescue -C -f -r3 /dev/raw/raw1 /dev/sdc1 mapfile
     raw /dev/raw/raw1 0 0
     e2fsck -v -f /dev/sdc1
     mount -t ext2 -o ro /dev/sdc1 /mnt
</pre>
 <div class=node>
<a name=Command-mode></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Fill-mode>Fill mode</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Direct-disc-access>Direct disc access</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>12 Copying parts of the input file on demand</h2>
<p><a name=index-command-mode-16></a>
The command mode of ddrescue implements a scripting interface similar to
the one of <a href=http://www.gnu.org/software/ed/manual/ed_manual.html>ed</a>. 
In this mode commands are read from the standard input and executed to copy
parts of the input file to the output file, retrieve information from the
mapfile, or write the mapfile to disc. Ddrescue's responses are written to
standard output. "done\n" for a successfully executed command, "error\n" for
a failed command (for example because of wrong arguments), and
"error:&nbsp;<var>error&nbsp;message</var>\n" for serious or fatal errors like write
errors.
 <p>If end-of-file is detected on standard input, ddrescue discards any partial
command being read and executes the '<samp><span class=samp>f</span></samp>' (finish) command.
 <p>All ddrescue commands are single characters, though some require additonal
parameters separated by spaces. Only one command is allowed per line. 
Ddrescue recognizes the following commands:
 <dl>
<dt><code>c </code><var>pos</var> <var>size</var><dd>Copy command. Copies a block of data from <var>infile</var> to <var>outfile</var> and
updates the internal copy of the mapfile. The areas already marked as
finished in the mapfile are not copied again.
 <br><dt><code>f</code><dd>Finish command. Compacts the internal copy of the mapfile and writes it to
<var>mapfile</var> (if it was specified in the command line). Then prints
"done\n" to standard output and quits. On startup, the mapfile is first
compacted and then split following the rescue domain borders. The finish
command compacts the mapfile again before exiting. If writing <var>mapfile</var>
to disc fails, a non-interactive emergency save is tried before exiting. 
See <a href=#Emergency-save>Emergency save</a>.
 <br><dt><code>q</code><dd>Quit command. Exits ddrescue. Does not update the mapfile.
 <br><dt><code>s </code><var>pos</var> <var>size</var><dd>Status command. Writes to standard output one or more lines in mapfile
format (see <a href=#Mapfile-structure>Mapfile structure</a>), showing the status of the areas included
in the block requested. A line consisting of the string "done" marks the end
of the list.
 <br><dt><code>u</code><dd>Update mapfile command. Writes the internal copy of the mapfile to
<var>mapfile</var> (if it was specified in the command line). If update mapfile
fails, you may try to fix the problem, for example deleting some files to
make room for <var>mapfile</var>, before trying to update it again.
 </dl>
<div class=node>
<a name=Fill-mode></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Generate-mode>Generate mode</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Command-mode>Command mode</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>13 Fill mode</h2>
<p><a name=index-fill-Mode-17></a>
When ddrescue is invoked with the option '<samp><span class=samp>--fill-mode</span></samp>' it operates in
"fill mode", which is different from the default "rescue mode". That is, in
"fill mode" ddrescue does not rescue anything. It only fills with data read
from <var>infile</var> the blocks of <var>outfile</var> whose status character from
<var>mapfile</var> coincides with one of the type characters specified in the
argument to '<samp><span class=samp>--fill-mode</span></samp>'.
 <p>If the argument to '<samp><span class=samp>--fill-mode</span></samp>' contains an '<samp><span class=samp>l</span></samp>', ddrescue will
write location data (position, sector number, and status) into each sector
filled. With bad sectors filled in this way, it should be possible to retry
the recovery of important files, as the location of the error is known by
looking into the unfinished copy of the file.
 <p>In fill mode <var>infile</var> does not need to be seekable and it may be of
any size. If it is too small, the data will be duplicated as many times
as necessary to fill the input buffer. If it is too big, only the data
needed to fill the input buffer will be read. Then the same data will be
written to every cluster or sector to be filled.
 <p>Note that in fill mode <var>infile</var> is always read from position 0. If
you specify a '<samp><span class=samp>--input-position</span></samp>', it refers to the original
<var>infile</var> from which <var>mapfile</var> was built, and is only used to
calculate the offset between input and output positions.
 <p>Note also that when filling the <var>infile</var> of the original rescue run
you should not set '<samp><span class=samp>--output-position</span></samp>', whereas when filling the
<var>outfile</var> of the original rescue run you should keep the original
offset between '<samp><span class=samp>--input-position</span></samp>' and '<samp><span class=samp>--output-position</span></samp>'.
 <p>The option '<samp><span class=samp>--fill-mode</span></samp>' implies '<samp><span class=samp>--complete-only</span></samp>'.
 <p>In fill mode <var>mapfile</var> is updated to allow resumability when
interrupted or in case of a crash, but as nothing is being rescued
<var>mapfile</var> is not destroyed. The status line is the only part of
<var>mapfile</var> that is modified.
 <pre class=sp></pre>
The fill mode has a number of uses. See the following examples:
<p class=noindent>Example 1: Mark parts of the rescued copy to allow finding them when
examined in an hex editor. For example, the following command line fills
all blocks marked as '<samp><span class=samp>-</span></samp>' (bad-sector) with copies of the string
'<samp><span class=samp>BAD-SECTOR&nbsp;</span></samp>':
<pre class=example>     ddrescue --fill-mode=- &lt;(printf "BAD-SECTOR ") outfile mapfile
</pre>
 <p class=noindent>Example 2: Wipe only the good sectors, leaving the bad sectors alone. 
This way, the drive will still test bad (i.e., with unreadable sectors). 
This is the fastest way of wiping a failing drive, and is especially
useful when sending the drive back to the manufacturer for warranty
replacement.
<pre class=example>     ddrescue --fill-mode=+ --force /dev/zero bad_drive mapfile
</pre>
 <p class=noindent>Example 3: Force the drive to remap the bad sectors, making it usable
again. If the drive has only a few bad sectors, and they are not caused
by drive age, you can probably just rewrite those sectors, and the drive
will reallocate them automatically to new "spare" sectors that it keeps
for just this purpose. WARNING! This may not work on your drive.
<pre class=example>     ddrescue --fill-mode=- -f --synchronous /dev/zero bad_drive mapfile
</pre>
 <pre class=sp></pre>
Fill mode can also help you to figure out, independently of the file
system used, what files are partially or entirely in the bad areas of
the disc. Just follow these steps:
 <p>1) Copy the damaged drive with ddrescue until finished. Don't use sparse
writes. This yields a mapfile containing only finished ('<samp><span class=samp>+</span></samp>') and
bad-sector ('<samp><span class=samp>-</span></samp>') blocks.
 <p>2) Fill the bad-sector blocks of the copied drive or image file with a
string not present in any file, for example "DEADBEEF". Use
'<samp><span class=samp>--fill-mode=l-</span></samp>' if you want location data.
 <p>3) Mount the copied drive (or the image file, via loopback device)
read-only.
 <p>4) Grep for the fill string in all the files. Those files containing the
string reside (at least partially) in damaged disc areas. Note that if
all the damaged areas are in unused space, grep will not find the string
in any file, which means that no files are damaged.
 <p>5) Take note of the location data of any important files that you want
to retry.
 <p>6) Unmount the copied drive or image file.
 <p>7) Retry the sectors belonging to the important files until they are
rescued or until it is clear that they can't be rescued.
 <p>8) Optionally fill the bad-sector blocks of the copied drive or image
file with zeros to restore the disc image.
<p class=noindent>Example 4: Figure out what files are in the bad areas of the disc.
<pre class=example>     ddrescue -b2048 /dev/cdrom cdimage mapfile
     printf "DEADBEEF" &gt; tmpfile
     ddrescue --fill-mode=l- tmpfile cdimage mapfile
     rm tmpfile
     mount -t iso9660 -o loop,ro cdimage /mnt/cdimage
     find /mnt/cdimage -type f -exec grep -l "DEADBEEF" '{}' ';'
       (note that my_thesis.txt has a bad sector at pos 0x12345000)
     umount /mnt/cdimage
     ddrescue -b2048 -i0x12345000 -s2048 -dr9 /dev/cdrom cdimage mapfile
     ddrescue --fill-mode=- /dev/zero cdimage mapfile
     mount -t iso9660 -o loop,ro cdimage /mnt/cdimage
     cp -a /mnt/cdimage/my_thesis.txt /safe/place/my_thesis.txt
</pre>
 <div class=node>
<a name=Generate-mode></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Ddrescuelog>Ddrescuelog</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Fill-mode>Fill mode</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>14 Generate mode</h2>
<p><a name=index-generate-Mode-18></a>
When ddrescue is invoked with the option '<samp><span class=samp>--generate-mode</span></samp>' it operates
in "generate mode", which is different from the default "rescue mode". That
is, in "generate mode" ddrescue does not rescue anything. It only tries to
generate a <var>mapfile</var> for later use.
 <p>So you didn't read the manual and started ddrescue without a <var>mapfile</var>. 
Now, two days later, your computer crashed and you can't know how much data
ddrescue managed to save. And even worse, you can't resume the rescue; you
have to restart it from the very beginning.
 <p>Or maybe you started copying a drive with '<samp><span class=samp>dd&nbsp;conv=noerror,sync</span></samp>'
and are now in the same situation described above. In this case, note that
you can't use a copy made by dd unless it was invoked with the '<samp><span class=samp>sync</span></samp>'
conversion argument.
 <p>Don't despair (yet). Ddrescue can in some cases generate an approximate
<var>mapfile</var>, from <var>infile</var> and the (partial) copy in <var>outfile</var>,
that is almost as good as an exact <var>mapfile</var>. It makes this by simply
assuming that sectors containing all zeros were not rescued.
 <p>However, if the destination of the copy was a drive or a partition, (or an
existing regular file and truncation was not requested), most probably you
will need to restart ddrescue from the very beginning. (This time with a
<var>mapfile</var>, of course). The reason is that old data may be present in the
drive that have not been overwritten yet, and may be thus non-tried but
non-zero.
 <p>For example, if you first tried one of these commands:
<pre class=example>     ddrescue infile outfile
     or
     dd if=infile of=outfile conv=noerror,sync
</pre>
 <p>then you can generate an approximate mapfile with this command:
<pre class=example>     ddrescue --generate-mode infile outfile mapfile
</pre>
 <p class=noindent>Note that you must keep the original offset between
'<samp><span class=samp>--input-position</span></samp>' and '<samp><span class=samp>--output-position</span></samp>' of the original
rescue run.
<div class=node>
<a name=Ddrescuelog></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Invoking-ddrescuelog>Invoking ddrescuelog</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Generate-mode>Generate mode</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>15 Ddrescuelog</h2>
<p><a name=index-ddrescuelog-19></a>
Ddrescuelog is a tool that manipulates ddrescue mapfiles, shows mapfile
contents, converts mapfiles to/from other formats, compares mapfiles, tests
rescue status, and can delete a mapfile if the rescue is done. Ddrescuelog
operations can be restricted to one or several parts of the mapfile if the
domain setting options are used.
 <p>When performing logic operations (AND, OR, XOR) on mapfiles of different
extension, only the blocks present in both files are processed.
 <p>Here are some examples of how to use ddrescuelog, alone or in combination
with other tools.
 <pre class=sp></pre>
Example 1: Delete the mapfile if the rescue is finished (all data have
been recovered without errors left).
<pre class=example>     ddrescue -f /dev/sda /dev/sdb mapfile
     ddrescuelog -d mapfile
</pre>
 <pre class=sp></pre>
Example 2: Rescue two ext2 partitions in /dev/sda to
/dev/sdb and repair the file systems using badblock lists generated with
ddrescuelog. File system block size is 4096.<br>
Note: you do need to partition /dev/sdb beforehand.
<pre class=example>     fdisk /dev/sdb                                   # partition /dev/sdb
     ddrescue -f /dev/sda1 /dev/sdb1 mapfile1
     ddrescue -f /dev/sda2 /dev/sdb2 mapfile2
     ddrescuelog -l- -b4096 mapfile1 &gt; badblocks1
     ddrescuelog -l- -b4096 mapfile2 &gt; badblocks2
     e2fsck -v -f -L badblocks1 /dev/sdb1
     e2fsck -v -f -L badblocks2 /dev/sdb2
</pre>
 <pre class=sp></pre>
Example 3: Rescue a whole disc with two ext2 partitions in /dev/sda to
/dev/sdb and repair the file systems using badblock lists generated with
ddrescuelog. Disc sector size is 512, file system block size is 4096. 
Arguments to options '<samp><span class=samp>-i</span></samp>' and '<samp><span class=samp>-s</span></samp>' are the starting positions
and sizes of the partitions being rescued.<br>
Note: you don't need to partition /dev/sdb beforehand, but if the
partition table on /dev/sda is damaged, you'll need to recreate it
somehow on /dev/sdb.
<pre class=example>     ddrescue -f /dev/sda /dev/sdb mapfile
     fdisk /dev/sdb                                  # get partition sizes
     ddrescuelog -l- -b512 -i63s -o0 -s767457s -b4096 mapfile &gt; badblocks1
     ddrescuelog -l- -b512 -i767520s -o0 -s96520s -b4096 mapfile &gt; badblocks2
     e2fsck -v -f -L badblocks1 /dev/sdb1
     e2fsck -v -f -L badblocks2 /dev/sdb2
</pre>
 <div class=node>
<a name=Invoking-ddrescuelog></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Problems>Problems</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Ddrescuelog>Ddrescuelog</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>16 Invoking ddrescuelog</h2>
<p><a name=index-invoking-ddrescuelog-20></a>
The format for running ddrescuelog is:
<pre class=example>     ddrescuelog [<var>options</var>] <var>mapfile</var>
</pre>
 <p>Use '<samp><span class=samp>-</span></samp>' as <var>mapfile</var> to read the mapfile from standard input
(also in the options taking a mapfile argument) or to write the mapfile
created by '<samp><span class=samp>--create-mapfile</span></samp>' to standard output.
 <p>Ddrescuelog supports the following options:
 <dl>
<dt><code>-h</code><dt><code>--help</code><dd>Print an informative help message describing the options and exit.
 <br><dt><code>-V</code><dt><code>--version</code><dd>Print the version number of ddrescuelog on the standard output and exit. 
This version number should be included in all bug reports.
 <br><dt><code>-a </code><var>old_types</var><code>,</code><var>new_types</var><dt><code>--change-types=</code><var>old_types</var><code>,</code><var>new_types</var><dd>Change the status of every block in the rescue domain from one type in
<var>old_types</var> to the corresponding type in <var>new_types</var>, much like
the command '<samp><span class=samp>tr</span></samp>' does, and write the resulting mapfile to standard
output. <var>old_types</var> and <var>new_types</var> are strings of block status
characters as defined in the chapter Mapfile structure (see <a href=#Mapfile-structure>Mapfile structure</a>). Blocks whose status is not in <var>old_types</var> are left
unchanged. If <var>new_types</var> is shorter than <var>old_types</var> the last
type of <var>new_types</var> is repeated as many times as necessary.
 <br><dt><code>-A</code><dt><code>--annotate-mapfile</code><dd>Add comments containing the human-readable positions and sizes of the
blocks in <var>mapfile</var> which are included in the rescue domain, and
write the resulting mapfile to standard output.
 <br><dt><code>-b </code><var>bytes</var><dt><code>--block-size=</code><var>bytes</var><dd>Block size used by ddrescuelog. Depending on the requested operation it
may be the sector size of the input device, the block size of the
rescued file system, etc. Defaults to 512.
 <br><dt><code>-B</code><dt><code>--binary-prefixes</code><dd>Show units with binary prefixes (powers of 1024).<br>
SI prefixes (powers of 1000) are used by default. (See table above,
<a href=#Invoking-ddrescue>Invoking ddrescue</a>).
 <br><dt><code>-c[</code><var>type1</var><var>type2</var><code>]</code><dt><code>--create-mapfile[=</code><var>type1</var><var>type2</var><code>]</code><dd>Create a <var>mapfile</var> from a list of block numbers read from standard
input. Only blocks included in the rescue domain will be added to
<var>mapfile</var>.
 <p><var>type1</var> and <var>type2</var> are block status characters as defined in
the chapter Mapfile structure (see <a href=#Mapfile-structure>Mapfile structure</a>). <var>type1</var>
sets the type for blocks included in the list, while <var>type2</var> sets
the type for the rest of <var>mapfile</var>. If not specified, <var>type1</var>
defaults to '<samp><span class=samp>+</span></samp>' and <var>type2</var> defaults to '<samp><span class=samp>-</span></samp>'.
 <br></p><dt><code>-C[</code><var>type</var><code>]</code><dt><code>--complete-mapfile[=</code><var>type</var><code>]</code><dd>Complete a synthetic (user fabricated) <var>mapfile</var> by filling the gaps
with blocks of type <var>type</var>, and write the completed mapfile to
standard output. <var>type</var> is one of the block status characters
defined in the chapter Mapfile structure (see <a href=#Mapfile-structure>Mapfile structure</a>). If
<var>type</var> is not specified, the gaps are filled with non-tried blocks. 
All gaps in <var>mapfile</var> are filled. Domain options are ignored.
 <br><dt><code>-d</code><dt><code>--delete-if-done</code><dd>Delete the given <var>mapfile</var> if all the blocks in the rescue domain
have been successfully recovered. The exit status is 0 if <var>mapfile</var>
could be deleted, 1 otherwise.
 <br><dt><code>-D</code><dt><code>--done-status</code><dd>Test if all the blocks in the rescue domain have been successfully
recovered. The exit status is 0 if all tested blocks are finished, 1
otherwise.
 <br><dt><code>-f</code><dt><code>--force</code><dd>Force overwrite of <var>mapfile</var>.
 <br><dt><code>-i </code><var>bytes</var><dt><code>--input-position=</code><var>bytes</var><dd>Starting position of the rescue domain, in bytes. Defaults to 0. It
refers to a position in the original <var>infile</var>.
 <br><dt><code>-l </code><var>types</var><dt><code>--list-blocks=</code><var>types</var><dd>Print on standard output the block numbers of the blocks specified as
any of <var>types</var> in <var>mapfile</var> and included in the rescue domain. 
<var>types</var> contains one or more of the block status characters defined
in the chapter Mapfile structure (see <a href=#Mapfile-structure>Mapfile structure</a>).
 <p>The list format is one block number per line in decimal, like the output
of the badblocks program, so that it can be used as input for e2fsck or
other similar filesystem repairing tool.
 <br></p><dt><code>-L</code><dt><code>--loose-domain</code><dd>Accept an incomplete synthetic (user fabricated) domain mapfile or
compare-as-domain mapfile, and fill the gaps in the list of data blocks
with non-tried blocks. The blocks in the mapfile must be strictly
ascending and non-overlapping, but they don't need to be contiguous. 
This option allows making quick edits to a mapfile without all the size
calculations involved in making all data blocks contiguous again.
 <br><dt><code>-m </code><var>file</var><dt><code>--domain-mapfile=</code><var>file</var><dd>Restrict the rescue domain to the blocks marked as finished in the
mapfile <var>file</var>.
 <br><dt><code>-n</code><dt><code>--invert-mapfile</code><dd>Invert the types of the blocks in <var>mapfile</var> which are included in
the rescue domain, and write the resulting mapfile to standard output. 
Finished blocks ('<samp><span class=samp>+</span></samp>') are changed to bad-sector ('<samp><span class=samp>-</span></samp>'), all
other types are changed to finished. '<samp><span class=samp>--invert-mapfile</span></samp>' is
equivalent to '<samp><span class=samp>--change-types=?*/-+,++++-</span></samp>'
 <br><dt><code>-o </code><var>bytes</var><dt><code>--output-position=</code><var>bytes</var><dd>Starting position of the image of the rescue domain in the original
<var>outfile</var>, in bytes. Is used by the option '<samp><span class=samp>--list-blocks</span></samp>'. 
Defaults to '<samp><span class=samp>--input-position</span></samp>'.
 <br><dt><code>-p </code><var>file</var><dt><code>--compare-mapfile=</code><var>file</var><dd>Compare the types of the blocks included in the rescue domain. The exit
status is 0 if all the blocks tested are the same in both <var>file</var> and
<var>mapfile</var>, 1 otherwise.
 <br><dt><code>-P </code><var>file</var><dt><code>--compare-as-domain=</code><var>file</var><dd>Compare only the blocks marked as finished in the rescue domain. The
exit status is 0 if all the blocks tested are the same in both
<var>file</var> and <var>mapfile</var>, 1 otherwise. Two files comparing equal
with this option are equivalent when used as domain mapfiles.
 <br><dt><code>-q</code><dt><code>--quiet</code><dd>Quiet operation. Suppress all messages.
 <br><dt><code>-s </code><var>bytes</var><dt><code>--size=</code><var>bytes</var><dd>Maximum size of the rescue domain in bytes. It refers to a size in the
original <var>infile</var>.
 <br><dt><code>-t</code><dt><code>--show-status</code><dd>Print a summary of the contents of each <var>mapfile</var> to the standard
output. This option allows more than one <var>mapfile</var>. If the domain
setting options are used, the summary can be restricted to one or
several parts of <var>mapfile</var>.
 <br><dt><code>-v</code><dt><code>--verbose</code><dd>Verbose mode. Further -v's (up to 4) increase the verbosity level.
 <br><dt><code>-x </code><var>file</var><dt><code>--xor-mapfile=</code><var>file</var><dd>Perform a logical XOR (exclusive OR) operation between the finished
blocks in <var>file</var> and those in <var>mapfile</var>, and write the resulting
mapfile to standard output. In other words, in the resulting mapfile a
block is only shown as finished if it was finished in either of the two
input mapfiles but not in both.
 <br><dt><code>-y </code><var>file</var><dt><code>--and-mapfile=</code><var>file</var><dd>Perform a logical AND operation between the finished blocks in
<var>file</var> and those in <var>mapfile</var>, and write the resulting mapfile
to standard output. In other words, in the resulting mapfile a block is
only shown as finished if it was finished in both input mapfiles.
 <br><dt><code>-z </code><var>file</var><dt><code>--or-mapfile=</code><var>file</var><dd>Perform a logical OR operation between the finished blocks in <var>file</var>
and those in <var>mapfile</var>, and write the resulting mapfile to standard
output. In other words, in the resulting mapfile a block is shown as
finished if it was finished in either of the two input mapfiles.
 <br><dt><code>--shift</code><dd>Shift the positions of all the blocks in <var>mapfile</var> by the offset
('<samp><span class=samp>--output-position</span></samp>' - '<samp><span class=samp>--input-position</span></samp>'), and write the
resulting mapfile to standard output. Either '<samp><span class=samp>--input-position</span></samp>' or
'<samp><span class=samp>--output-position</span></samp>' must be 0. If the offset is positive, a
non-tried block is inserted before the first block. Any blocks beyond
the end of the rescue domain are removed before performing the shift.
 </dl>
 <p>Exit status: 0 for a normal exit, 1 for environmental problems (file not
found, invalid flags, I/O errors, etc), 2 to indicate a corrupt or
invalid input file, 3 for an internal consistency error (eg, bug) which
caused ddrescuelog to panic.
<div class=node>
<a name=Problems></a>
<p><hr>
Next:&nbsp;<a rel=next accesskey=n href=#Concept-index>Concept index</a>,
Previous:&nbsp;<a rel=previous accesskey=p href=#Invoking-ddrescuelog>Invoking ddrescuelog</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=chapter>17 Reporting bugs</h2>
<p><a name=index-bugs-21></a><a name=index-getting-help-22></a>
There are probably bugs in ddrescue. There are certainly errors and
omissions in this manual. If you report them, they will get fixed. If
you don't, no one will ever know about them and they will remain unfixed
for all eternity, if not longer.
 <p>If you find a bug in GNU ddrescue, please send electronic mail to
<a href=mailto:bug-ddrescue@gnu.org>bug-ddrescue@gnu.org</a>. Include the version number, which you can
find by running '<samp><span class=samp>ddrescue&nbsp;--version</span></samp>'.
<div class=node>
<a name=Concept-index></a>
<p><hr>
Previous:&nbsp;<a rel=previous accesskey=p href=#Problems>Problems</a>,
Up:&nbsp;<a rel=up accesskey=u href=#Top>Top</a>
</div>
<h2 class=unnumbered>Concept index</h2>
<ul class=index-cp compact>
<li><a href=#index-algorithm-4>algorithm</a>: <a href=#Algorithm>Algorithm</a></li>
<li><a href=#index-basic-concepts-2>basic concepts</a>: <a href=#Basic-concepts>Basic concepts</a></li>
<li><a href=#index-bugs-21>bugs</a>: <a href=#Problems>Problems</a></li>
<li><a href=#index-command-mode-16>command mode</a>: <a href=#Command-mode>Command mode</a></li>
<li><a href=#index-ddrescuelog-19>ddrescuelog</a>: <a href=#Ddrescuelog>Ddrescuelog</a></li>
<li><a href=#index-direct-disc-access-14>direct disc access</a>: <a href=#Direct-disc-access>Direct disc access</a></li>
<li><a href=#index-emergency-save-11>emergency save</a>: <a href=#Emergency-save>Emergency save</a></li>
<li><a href=#index-examples-13>examples</a>: <a href=#Examples>Examples</a></li>
<li><a href=#index-fill-Mode-17>fill Mode</a>: <a href=#Fill-mode>Fill mode</a></li>
<li><a href=#index-generate-Mode-18>generate Mode</a>: <a href=#Generate-mode>Generate mode</a></li>
<li><a href=#index-getting-help-22>getting help</a>: <a href=#Problems>Problems</a></li>
<li><a href=#index-introduction-1>introduction</a>: <a href=#Introduction>Introduction</a></li>
<li><a href=#index-invoking-ddrescue-6>invoking ddrescue</a>: <a href=#Invoking-ddrescue>Invoking ddrescue</a></li>
<li><a href=#index-invoking-ddrescuelog-20>invoking ddrescuelog</a>: <a href=#Invoking-ddrescuelog>Invoking ddrescuelog</a></li>
<li><a href=#index-mapfile-structure-10>mapfile structure</a>: <a href=#Mapfile-structure>Mapfile structure</a></li>
<li><a href=#index-optical-media-12>optical media</a>: <a href=#Optical-media>Optical media</a></li>
<li><a href=#index-options-7>options</a>: <a href=#Invoking-ddrescue>Invoking ddrescue</a></li>
<li><a href=#index-output-5>output</a>: <a href=#Output>Output</a></li>
<li><a href=#index-raw-devices-15>raw devices</a>: <a href=#Direct-disc-access>Direct disc access</a></li>
<li><a href=#index-usage-8>usage</a>: <a href=#Invoking-ddrescue>Invoking ddrescue</a></li>
<li><a href=#index-using-ddrescue-safely-3>using ddrescue safely</a>: <a href=#Important-advice>Important advice</a></li>
<li><a href=#index-version-9>version</a>: <a href=#Invoking-ddrescue>Invoking ddrescue</a></li>
</ul>
